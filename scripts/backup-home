#!/usr/bin/env bash

# Restic Backup Script
# Place this script in /usr/local/bin/ and make it executable: chmod +x /usr/local/bin/backup-restic

set -euo pipefail

# Configuration - Adjust these variables
BACKUP_NAME="$(hostname)-backup"
RESTIC_REPOSITORY="${RESTIC_REPOSITORY:-~/mnt/xps-13}"  # Can be overridden by env var
export RESTIC_PASSWORD_COMMAND="pass show restic-backup/mnt/xps-13"
BACKUP_PATHS=(
    "$HOME"
    # "/etc"
    # "/opt"
    # Add more paths as needed
)
EXCLUDE_FILE="${HOME}/.restic-backup-exclude"
LOG_FILE="/var/log/restic/restic-backup.log"
RETENTION_DAILY=7
RETENTION_WEEKLY=4
RETENTION_MONTHLY=6
RETENTION_YEARLY=2

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    local level="$1"
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    case "$level" in
        ERROR)
            echo -e "${RED}[ERROR]${NC} $message" >&2
            echo "[$timestamp] [ERROR] $message" >> "$LOG_FILE"
            ;;
        WARN)
            echo -e "${YELLOW}[WARN]${NC} $message"
            echo "[$timestamp] [WARN] $message" >> "$LOG_FILE"
            ;;
        INFO)
            echo -e "${GREEN}[INFO]${NC} $message"
            echo "[$timestamp] [INFO] $message" >> "$LOG_FILE"
            ;;
        DEBUG)
            echo -e "${BLUE}[DEBUG]${NC} $message"
            echo "[$timestamp] [DEBUG] $message" >> "$LOG_FILE"
            ;;
    esac
}

# Check if running as root for system paths
check_permissions() {
    if [[ $EUID -eq 0 ]]; then
        log INFO "Running as root - can backup system files"
    else
        log WARN "Not running as root - some system files may be skipped"
    fi
}

# Check prerequisites
check_prerequisites() {
    log INFO "Checking prerequisites..."

    # Check if restic is installed
    if ! command -v restic &> /dev/null; then
        log ERROR "restic is not installed or not in PATH"
        exit 1
    fi

    # Create log directory if it doesn't exist
    mkdir -p "$(dirname "$LOG_FILE")"

    # Create exclude file if it doesn't exist
    if [[ ! -f "$EXCLUDE_FILE" ]]; then
        log WARN "Exclude file not found: $EXCLUDE_FILE"
        log INFO "Creating default exclude file..."
        create_default_exclude_file
    fi

    log INFO "Prerequisites check passed"
}

# Initialize repository if it doesn't exist
init_repo() {
    log INFO "Checking if repository exists..."

    if ! restic -r "$RESTIC_REPOSITORY" --password-command "$RESTIC_PASSWORD_COMMAND" cat config &>/dev/null; then
        log INFO "Repository doesn't exist, initializing..."
        restic init -r "$RESTIC_REPOSITORY" --password-command "$RESTIC_PASSWORD_COMMAND"
        log INFO "Repository initialized successfully"
    else
        log INFO "Repository already exists"
    fi
}

# Perform backup
perform_backup() {
    log INFO "Starting backup: $BACKUP_NAME"
    log INFO "Repository: $RESTIC_REPOSITORY"
    log INFO "Backup paths: ${BACKUP_PATHS[*]}"

    local backup_args=(
        backup
        -r "$RESTIC_REPOSITORY"
        --password-command "$RESTIC_PASSWORD_COMMAND"
        --tag "$BACKUP_NAME"
        --exclude-file "$EXCLUDE_FILE"
        --one-file-system
        --compression auto
        "${BACKUP_PATHS[@]}"
    )

    if restic "${backup_args[@]}"; then
        log INFO "Backup completed successfully"
        return 0
    else
        log ERROR "Backup failed"
        return 1
    fi
}

# Clean old backups
cleanup_old_backups() {
    log INFO "Cleaning up old backups..."

    local forget_args=(
        forget
        -r "$RESTIC_REPOSITORY"
        --password-command "$RESTIC_PASSWORD_COMMAND"
        --tag "$BACKUP_NAME"
        --keep-daily "$RETENTION_DAILY"
        --keep-weekly "$RETENTION_WEEKLY"
        --keep-monthly "$RETENTION_MONTHLY"
        --keep-yearly "$RETENTION_YEARLY"
        --prune
    )

    if restic "${forget_args[@]}"; then
        log INFO "Cleanup completed successfully"
        return 0
    else
        log ERROR "Cleanup failed"
        return 1
    fi
}

# Check repository integrity
check_repo() {
    log INFO "Checking repository integrity..."

    if restic -r "$RESTIC_REPOSITORY" --password-command "$RESTIC_PASSWORD_COMMAND" check --read-data-subset=10%; then
        log INFO "Repository check passed"
        return 0
    else
        log ERROR "Repository check failed"
        return 1
    fi
}

# Show backup statistics
show_stats() {
    log INFO "Backup statistics:"
    restic -r "$RESTIC_REPOSITORY" --password-command "$RESTIC_PASSWORD_COMMAND" stats --mode restore-size
}

# Send notification (optional)
send_notification() {
    local status="$1"
    local message="$2"

    # Uncomment and configure for your notification system
    # Examples:

    # Email notification
    # echo "$message" | mail -s "Backup $status: $BACKUP_NAME" admin@example.com

    # Slack notification
    # curl -X POST -H 'Content-type: application/json' \
    #   --data "{\"text\":\"Backup $status: $BACKUP_NAME - $message\"}" \
    #   YOUR_SLACK_WEBHOOK_URL

    # Desktop notification (if running in desktop environment)
    # notify-send "Backup $status" "$message"

    log INFO "Notification: $status - $message"
}

# Usage information
usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  -h, --help          Show this help message"
    echo "  -n, --no-cleanup    Skip cleanup of old backups"
    echo "  -c, --check-only    Only check repository integrity"
    echo "  -s, --stats         Show backup statistics"
    echo "  -v, --verbose       Enable verbose output"
    echo ""
    echo "Environment variables:"
    echo "  RESTIC_REPOSITORY      Repository path (default: /backup/restic-repo)"
    echo ""
}

# Main function
main() {
    local skip_cleanup=false
    local check_only=false
    local show_stats_only=false
    local verbose=false

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                usage
                exit 0
                ;;
            -n|--no-cleanup)
                skip_cleanup=true
                shift
                ;;
            -c|--check-only)
                check_only=true
                shift
                ;;
            -s|--stats)
                show_stats_only=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            *)
                log ERROR "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Enable verbose output if requested
    if [[ "$verbose" == true ]]; then
        export RESTIC_PROGRESS_FPS=1
    fi

    log INFO "=== Restic Backup Script Started ==="

    check_permissions
    check_prerequisites
    init_repo

    if [[ "$show_stats_only" == true ]]; then
        show_stats
        exit 0
    fi

    if [[ "$check_only" == true ]]; then
        if check_repo; then
            send_notification "SUCCESS" "Repository integrity check passed"
            exit 0
        else
            send_notification "FAILED" "Repository integrity check failed"
            exit 1
        fi
    fi

    # Perform the backup
    if perform_backup; then
        log INFO "Backup phase completed successfully"

        # Cleanup old backups unless skipped
        if [[ "$skip_cleanup" == false ]]; then
            if cleanup_old_backups; then
                log INFO "Cleanup phase completed successfully"
            else
                log WARN "Cleanup phase failed, but backup was successful"
            fi
        else
            log INFO "Skipping cleanup as requested"
        fi

        # Show final statistics
        show_stats

        send_notification "SUCCESS" "Backup completed successfully"
        log INFO "=== Backup Script Completed Successfully ==="
        exit 0
    else
        send_notification "FAILED" "Backup failed"
        log ERROR "=== Backup Script Failed ==="
        exit 1
    fi
}

# Handle interruption gracefully
trap 'log ERROR "Script interrupted"; exit 130' INT TERM

# Run main function
main "$@"
