#!/bin/bash
#
# ~/.mender.rc
#

MENDER_ROOT=${MENDER_ROOT:-$HOME/go/src/github.com/mendersoftware}
MENDER_ARTIFACT=${MENDER_ARTIFACT:-$MENDER_ROOT/mender-artifact}
MENDER_INTEGRATION=${MENDER_INTEGRATION:-$MENDER_ROOT/integration}
MENDER_JWT_TOKEN=""

_cleanup_acceptance_tests() {
    if [ $# -lt 2 ]; then
        return 1
    fi
    local service_name=$1
    local DOCKER_REPO=$2
    local pathname=$(pwd)

    for filename in $(ls $pathname/docs); do
        if [ -f $pathname/tests/$filename ]; then
            rm -f $pathname/tests/$filename
        fi
    done
    for filename in $(ls $MENDER_INTEGRATION/extra/travis-testing); do
        if [ -f $pathname/tests/$filename ]; then
            rm -f $pathname/tests/$filename
        fi
    done
    if [ -f $pathname/tests/mender-artifact ]; then
        rm -f $pathname/tests/mender-artifact
    fi
    if [ -f $pathname/tests/$service_name ]; then
        rm -f $pathname/tests/$service_name
    fi

    if [ -f $pathname/tests/coverage-acceptance.txt ]; then
        rm -f $pathname/tests/coverage-acceptance.txt
    fi
    if [ -f $pathname/tests/results.xml ]; then
        rm -f $pathname/tests/results.xml
    fi
    if [ -f $pathname/tests/private.pem ]; then
        rm -f $pathname/tests/private.pem
    fi
    if [ $(docker image ls -q $DOCKER_REPO:prtest | wc -l) -gt 0 ]; then
        docker rmi $DOCKER_REPO:prtest
    fi
    if [ $(docker image ls -q testing | wc -l) -gt 0 ]; then
        docker rmi testing
    fi

    rm $pathname/tests/acceptance.* 2>/dev/null
    return 0
}

run_acceptance_tests() {
    local cleanup=false
    local pathname=$(pwd)
    local compose_file=$pathname/tests/docker-compose-acceptance.yml
    for i in $(seq 1 $#); do
        case $1 in
            -help)
                echo "Flags be like:"
                echo "  -cleanup [only]      " \
                     "remove files and docker images generated by testing " \
                     "environment."
                echo "  -cleanup-only        same as -cleanup but skips tests."
                echo "  -compose-file <path> " \
                     "path to compose file (defaults to tests/docker-compose-acceptance.yml)"
                return 0
                ;;
            -cleanup)
                cleanup=true
                ;;
            -cleanup-only)
                cleanup="only"
                ;;
            -compose-file)
                compose_file="$2"
                ;;
            *)
                ;;
        esac
        shift 1
    done

    # Run go build to resolve service name
    go build -ldflags "-linkmode external -extldflags -static"
    if [ $? -gt 0 ]; then
        echo "run_acceptance_tests assumes working directory is at the " \
             "root (under GOPATH) of the service repository"
        return $?
    fi
    local service_name=$(ls -t | head -n1 | cut -f 1 -d " ")
    cp $service_name $pathname/tests

    # Resolve docker name
    local DOCKER_REPO="mendersoftware/${service_name}"
    if [[ $service_name == *"enterprise"* || $service_name == "tenantadm" ]]; then
        DOCKER_REPO="registry.mender.io/mendersoftware/${service_name}"
    fi

    # Clean up and return
    if [ $cleanup = "only" ]; then
        _cleanup_acceptance_tests $service_name $DOCKER_REPO
        return $?
    fi

    # Fetch mender-artifact
    if [ ! -f $pathname/tests/mender-artifact ]; then
        if [ -f $MENDER_ARTIFACT/mender-artifact ]; then
            cp $MENDER_ARTIFACT/mender-artifact $pathname/tests/mender-artifact
        else
            local ARTIFACT_BIN=$(which mender-artifact 2>/dev/null)
            if [ $? -eq 0 && -n $ARTIFACT_BIN ]; then
                cp $ARTIFACT_BIN $pathname/tests/mender-artifact
            else
                wget https://downloads.mender.io/mender-artifact/master/linux/mender-artifact
                if [ $? -eq 0 ]; then
                    chmod +x mender-artifact
                    mv mender-artifact $pathname/tests/mender-artifact
                else
                    echo "Unable to find mender-artifact binary"
                    return $?
                fi
            fi
        fi
    fi

    # Check if docker image needs to be built
    if [ $(docker image ls -q $DOCKER_REPO:prtest | wc -l) -gt 0 ]; then
        while true; do
            local YESNO
            read -p "Docker image ${DOCKER_REPO}:prtest already exists. Rebuild and replace? [y/N] " YESNO
            case $YESNO in
                [Yy]* )
                    # Remove old image
                    docker rmi $DOCKER_REPO:prtest
                    docker rmi testing
                    # Replace with fresh
                    docker build . -f Dockerfile.acceptance-testing -t $DOCKER_REPO:prtest
                    local ret=$?
                    if [ $ret -ne 0 ]; then
                        return $ret
                    fi
                    docker build tests -f tests/Dockerfile -t testing
                    ret=$?
                    if [ $ret -ne 0 ]; then
                        return $ret
                    fi
                    break
                    ;;
                [Nn]* )
                    break
                    ;;
                "")
                    break
                    ;;
                * )
            esac
        done
    else
            docker build . -f Dockerfile.acceptance-testing -t $DOCKER_REPO:prtest
            docker build tests -f tests/Dockerfile -t testing
    fi
    if [ -f keys/private.pem ]; then
        cp keys/private.pem tests/;
    fi

    cp $pathname/docs/* $pathname/tests/
    cp $MENDER_INTEGRATION/extra/travis-testing/* \
       $pathname/tests
    echo "TESTS_DIR=$pathname/tests $pathname/tests/run-test-environment acceptance $MENDER_INTEGRATION $compose_file -- $@"
    TESTS_DIR=$pathname/tests $pathname/tests/run-test-environment acceptance $MENDER_INTEGRATION $compose_file -- $@

    if [ $cleanup = true ]; then
        _cleanup_acceptance_tests $service_name $DOCKER_REPO
    fi
    return $?
}

function mender_generate_client() {
    local client_id=${1:-client}
    local private="$HOME/.cache/mender/${client_id}.pem"
    local public="$HOME/.cache/mender/${client_id}-pub.pem"
    local auth="$HOME/.cache/mender/${client_id}.json"
    openssl genpkey -algorithm RSA -out $private
    openssl rsa -in $private -pubout -out $public
    local pubkey=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' $public)
    cat <<- EOF > $auth
{"id_data":"{\"client_id\":\"${client_id}\"}","pubkey":"${pubkey}","tenant_token":"${MENDER_TENANT_TOKEN}"}
EOF
}

function mender_generate_client_ed25519() {
    local client_id=${1:-client}
    local private="$HOME/.cache/mender/${client_id}.pem"
    local public="$HOME/.cache/mender/${client_id}-pub.pem"
    local auth="$HOME/.cache/mender/${client_id}.json"
    openssl genpkey -algorithm ed25519 -out $private
    openssl pkey -in $private -pubout -out $public
    local pubkey=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' $public)
    cat <<- EOF > $auth
{"id_data":"{\"client_id\":\"${client_id}\"}","pubkey":"${pubkey}","tenant_token":"${MENDER_TENANT_TOKEN}"}
EOF
}

function mender_generate_client_ecdsa() {
    local client_id=${1:-client}
    local private="$HOME/.cache/mender/${client_id}.pem"
    local public="$HOME/.cache/mender/${client_id}-pub.pem"
    local auth="$HOME/.cache/mender/${client_id}.json"
    openssl ecparam -name prime256v1 -genkey -out $private
    openssl ec -in $private -pubout -out $public
    local pubkey=$(awk 'NF {sub(/\r/, ""); printf "%s\\n",$0;}' $public)
    cat <<- EOF > $auth
{"id_data":"{\"client_id\":\"${client_id}\"}","pubkey":"${pubkey}","tenant_token":"${MENDER_TENANT_TOKEN}"}
EOF
}

function mender_client_auth() {
    local client_id=${1:-client}
    local pkey="$HOME/.cache/mender/${client_id}.pem"
    local auth="$HOME/.cache/mender/${client_id}.json"
    local server_uri=${MENDER_SERVER_URI:-https://localhost}
    
    if [ ! -f $auth ]; then
        echo "[ERRO] Client authset not found (client_id: ${client_id})"
        return
    elif [ -n $MENDER_SERVER_URI ]; then
        echo "[WARN] MENDER_SERVER_URI not set defaulting to ${server_uri}"
    fi
    local normalized_auth=$(cat $auth | jq -c | tr -d '\r\n')
    local mender_signature=$(echo -n $normalized_auth | \
                             openssl dgst -sha256 -sign $pkey | openssl base64 -A)
    
    curl -k -vv -s \
        -H "Content-Type: application/json" \
        -H "X-MEN-Signature: ${mender_signature}" \
        -d "${normalized_auth}" \
        "${server_uri}/api/devices/v1/authentication/auth_requests"
}

function mender_login() {
    local username
    local password
    local server_uri=${MENDER_SERVER_URI:-https://localhost}

    if [ -n $MENDER_SERVER_URI ]; then
        echo "[WARN] MENDER_SERVER_URI not set defaulting to ${server_uri}"
    fi

    if [ $# -ge 1 ]; then 
        username=$1
    else
        read -r -p 'EMail: ' username
    fi
    if [ $# -ge 2 ]; then 
        password=$2
    else
        stty -echo
        read -r -p 'Password: ' password
        stty echo
    fi
    MENDER_JWT_TOKEN=$(curl -k -s -u "${username}:${password}" \
            ${server_uri}/api/management/v1/useradm/auth/login -X POST)
    echo $MENDER_JWT_TOKEN
}

function mender_preauth_client() {
    local client_id=${1:-client}
    local pkey="$HOME/.cache/mender/${client_id}.pem"
    local auth="$HOME/.cache/mender/${client_id}.json"
    local server_uri=${MENDER_SERVER_URI:-https://localhost}
    echo $MENDER_JWT_TOKEN
    
    if [ ! -f $auth ]; then
        echo "[ERRO] Client authset not found (client_id: ${client_id})"
        return
    elif [ ! -n "${MENDER_JWT_TOKEN}" ]; then
        echo "[ERRO] Please login (CMD: mender_login)"
        return
    elif [ ! -n "${MENDER_SERVER_URI}" ]; then
        echo "[WARN] MENDER_SERVER_URI not set defaulting to ${server_uri}"
    fi
    local id_data=$(cat $auth | jq .id_data | sed 's:\(^"\|"$\|\\\)::g')
    local preauth_set=$(cat $auth | jq "del(.tenant_token)|del(.id_data)|.identity_data=${id_data}")
    echo $preauth_set
    curl -k \
            -H "Authorization: Bearer ${MENDER_JWT_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "${preauth_set}" \
            "${server_uri}/api/management/v2/devauth/devices"
}

function identify_licenses() {
    local LAST_COVERED="not/vendor"
    local LICENSE_FILES
    local PARENT_DIR
    local FOUND
    local ret=0
    local classifier_bin="$GOPATH/bin/identify_license"
    if [ ! -e $classifier_bin ]; then
        go get github.com/google/licenseclassifier/tools/identify_license >&2
        if [ $? != 0 ]; then
            echo "!!! Failed to install 'identify_license' binary" >&2
            return $?
        fi
    fi
    for gofile in $(find vendor -name '*.go' -type f)
    do
        if [ "${gofile::${#LAST_COVERED}}" = "${LAST_COVERED}" ]; then
            continue
        fi
        PARENT_DIR="$(dirname "$gofile")"
        FOUND=0
        while [ "$PARENT_DIR" != "vendor" ]
        do
            # Either we need to find a license file, or the file must be
            # covered by one of the license files specified in
            # KNOWN_LICENSE_FILES.
            LICENSE_FILES=$(find "$PARENT_DIR" -maxdepth 1 -iname 'LICEN[SC]E' -o -iname 'LICEN[SC]E.*' -o -iname 'COPYING')
            if [ ! -z "${LICENSE_FILES}" ]
            then
                FOUND=1
                for file in $LICENSE_FILES; do
                    LICENSE=$($classifier_bin -threshold 0.7 $file 2>/dev/null)
                    if [ $? != 0 ]; then
                        echo "??? Failed to identify license of ${file}" >&2
                    else
                        LICENSE=$(echo $LICENSE | sed 's@^'"${file}"':\ \(.\+\?\)\ (.*$@\1@')
                        echo "$(sha256sum $file) # ${LICENSE}"
                    fi
                done
                LAST_COVERED="$PARENT_DIR"
                break
            fi
            PARENT_DIR="$(dirname "$PARENT_DIR")"
        done
        if [ $FOUND != 1 ]
        then
            echo "!!! No license file to cover $gofile" >&2
            ret=1
            break
        fi
    done
    return $ret
}
